<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Container Network 1">




  <meta name="keywords" content="network,">





  <link rel="alternate" href="/default" title="WLBF">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2022/02/15/container-network-1/">


<meta name="description" content="参考文章：networking-4-docker-sigle-host bridge 是 docker 默认的网络模型，bridge 网络模型解决了单宿主机上的容器之间的通信以及容器访问外部和对外暴露服务的问题。接下来尝试通过 linux 虚拟网络设备 + iptables + 路由表来模拟类似的功能。 bridge 网络模拟基本的网络拓扑图如下所示：：   首先创建两个 netns 网络命名空间">
<meta name="keywords" content="network">
<meta property="og:type" content="article">
<meta property="og:title" content="Container Network 1">
<meta property="og:url" content="http://yoursite.com/2022/02/15/container-network-1/index.html">
<meta property="og:site_name" content="WLBF">
<meta property="og:description" content="参考文章：networking-4-docker-sigle-host bridge 是 docker 默认的网络模型，bridge 网络模型解决了单宿主机上的容器之间的通信以及容器访问外部和对外暴露服务的问题。接下来尝试通过 linux 虚拟网络设备 + iptables + 路由表来模拟类似的功能。 bridge 网络模拟基本的网络拓扑图如下所示：：   首先创建两个 netns 网络命名空间">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.imgur.com/mU1pWyv.png">
<meta property="og:updated_time" content="2022-02-22T12:17:10.996Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Container Network 1">
<meta name="twitter:description" content="参考文章：networking-4-docker-sigle-host bridge 是 docker 默认的网络模型，bridge 网络模型解决了单宿主机上的容器之间的通信以及容器访问外部和对外暴露服务的问题。接下来尝试通过 linux 虚拟网络设备 + iptables + 路由表来模拟类似的功能。 bridge 网络模拟基本的网络拓扑图如下所示：：   首先创建两个 netns 网络命名空间">
<meta name="twitter:image" content="https://i.imgur.com/mU1pWyv.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Container Network 1 - WLBF </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">WLBF</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Container Network 1
        
      </h1>

      <time class="post-time">
          Feb 15 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>参考文章：<a href="https://morven.life/posts/networking-4-docker-sigle-host/" target="_blank" rel="noopener">networking-4-docker-sigle-host</a></p>
<p>bridge 是 docker 默认的网络模型，bridge 网络模型解决了单宿主机上的容器之间的通信以及容器访问外部和对外暴露服务的问题。接下来尝试通过 linux 虚拟网络设备 + iptables + 路由表来模拟类似的功能。</p>
<h3 id="bridge-网络模拟"><a href="#bridge-网络模拟" class="headerlink" title="bridge 网络模拟"></a>bridge 网络模拟</h3><p>基本的网络拓扑图如下所示：：</p>
<p><img src="https://i.imgur.com/mU1pWyv.png" alt="bridge"></p>
<ol>
<li>首先创建两个 netns 网络命名空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip netns add netns_A</span></span><br><span class="line"><span class="comment"># ip netns add netns_B</span></span><br><span class="line"><span class="comment"># ip netns</span></span><br><span class="line">netns_B</span><br><span class="line">netns_A</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 default 网络命名空间中创建网桥设备 mybr0，并分配 IP 地址172.18.0.1/16使其成为对应子网的网关：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 172.18.0.1/16 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set mybr0 up</span></span><br><span class="line"><span class="comment"># ip link show mybr0</span></span><br><span class="line">3: mybr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 1e:51:a0:ee:ad:98 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="comment"># ip route</span></span><br><span class="line">...</span><br><span class="line">172.18.0.0/16 dev mybr0 proto kernel scope link src 172.18.0.1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接下来，创建 veth 设备对并连接在第一步创建的两个网络命名空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link add vethA type veth peer name vethpA</span></span><br><span class="line"><span class="comment"># ip link show vethA</span></span><br><span class="line">5: vethA@vethpA: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether be:c8:3d:b2:e4:85 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="comment"># ip link show vethpA</span></span><br><span class="line">13: vethpA@vethA: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 86:d6:16:43:54:9e brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>将上一步创建的 veth 设备对的一端 vethA 连接到 mybr0 网桥并启动：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link set dev vethA master mybr0</span></span><br><span class="line"><span class="comment"># ip link set vethA up</span></span><br><span class="line"><span class="comment"># bridge link</span></span><br><span class="line">5: vethA@vethpA: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP,M-DOWN&gt; mtu 1500 master mybr0 state disabled priority 32 cost 2</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>将 veth 设备对的另一端 vethpA 放到网络命名空间 netns_A 中并配置 IP 启动：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link set vethpA netns netns_A</span></span><br><span class="line"><span class="comment"># ip netns exec netns_A ip link set vethpA name eth0</span></span><br><span class="line"><span class="comment"># ip netns exec netns_A ip addr add 172.18.0.2/16 dev eth0</span></span><br><span class="line"><span class="comment"># ip netns exec netns_A ip link set eth0 up</span></span><br><span class="line"><span class="comment"># ip netns exec netns_A ip addr show type veth</span></span><br><span class="line">4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 42:a2:e6:be:e1:00 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::40a2:e6ff:febe:e100/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>现在就可以验证从 netns_A 网络命名空间中访问 mybr0 网关：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip netns exec netns_A ping -c 2 172.18.0.1</span></span><br><span class="line">PING 172.18.0.1 (172.18.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=1 ttl=64 time=0.089 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=2 ttl=64 time=0.064 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1024ms</span><br><span class="line">rtt min/avg/max/mdev = 0.064/0.076/0.089/0.012 ms</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>接下来，按照上述步骤创建连接 default 和 netns_B 网络命名空间 veth 设备对：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip netns exec netns_A ip route add default via 172.18.0.1</span></span><br><span class="line"><span class="comment"># ip netns exec netns_A ip route</span></span><br><span class="line">default via 172.18.0.1 dev eth0 </span><br><span class="line">172.18.0.0/16 dev eth0 proto kernel scope link src 172.18.0.2</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>接下来，按照上述步骤创建连接 default 和 netns_B 网络命名空间 veth 设备对：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip link add vethB type veth peer name vethpB</span></span><br><span class="line"><span class="comment"># ip link set dev vethB master mybr0</span></span><br><span class="line"><span class="comment"># ip link set vethB up</span></span><br><span class="line"><span class="comment"># ip link set vethpB netns netns_B</span></span><br><span class="line"><span class="comment"># ip netns exec netns_B ip link set vethpB name eth0</span></span><br><span class="line"><span class="comment"># ip netns exec netns_B ip addr add 172.18.0.3/16 dev eth0</span></span><br><span class="line"><span class="comment"># ip netns exec netns_B ip link set eth0 up</span></span><br><span class="line"><span class="comment"># ip netns exec netns_B ip route add default via 172.18.0.1</span></span><br><span class="line"><span class="comment"># ip netns exec netns_B ip add show eth0</span></span><br><span class="line">6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 4a:31:85:5e:39:6e brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.3/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::4831:85ff:fe5e:396e/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># ip netns exec netns_B ip route show</span></span><br><span class="line">default via 172.18.0.1 dev eth0 </span><br><span class="line">172.18.0.0/16 dev eth0 proto kernel scope link src 172.18.0.3</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>默认情况下 Linux 会把网桥设备 bridge 的转发功能禁用，所以在 netns_A 里面是 ping 不通 netns_B 的，需要额外增加一条 iptables 规则才能激活网桥设备 bridge 的转发功能：<br>(在我的测试过程中似乎并不需要这一步，系统 ubuntu 20.04)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A FORWARD -i mybr0 -j ACCEPT</span></span><br></pre></td></tr></table></figure>
<ol start="10">
<li>现在就可以验证两个网络命名空间之间可以互通：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip netns exec netns_A ping -c 2 172.18.0.3</span></span><br><span class="line">PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.027 ms</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.054 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.3 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1025ms</span><br><span class="line">rtt min/avg/max/mdev = 0.027/0.040/0.054/0.013 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip netns exec netns_B ping -c 2 172.18.0.2</span></span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.063 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.070 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = 0.063/0.066/0.070/0.003 ms</span><br></pre></td></tr></table></figure>
<p>实际上，此时两个网络命名空间处于同一个子网中，所以网桥设备 mybr0 还是工作在二层（数据链路层），只需要对方的 MAC 地址就可以访问。</p>
<p>但是如果需要从两个网络命名空间访问其他网段的地址，这个时候网桥设备 mybr0 设置为默认网关地址就发挥作用了：来自于两个网络命名空间的数据包发现目标 IP 地址并不是本子网地址，于是发给网关 mybr0，此时网桥设备 mybr0 其实工作在三层（IP网络层），它收到数据包之后，查看本地路由与目标 IP 地址，寻找下一跳的地址</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>这时候从 netns 网络命名空间中还无法访问到公网地址，首先由于系统默认不进行 IP forwarding，mybr0 的数据包没有通过 ens3 发从出去。首先要打开 IP forwarding 开关，之后由于发出的 ICMP 包没有做 SNAT，返回的 IP 包无法回到对应子网内。这时候通过 iptables 配置 SNAT 来解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line"><span class="comment"># iptables -t nat -A POSTROUTING -s 172.18.0.0/16  -o ens3 -j MASQUERADE</span></span><br><span class="line"><span class="comment"># iptables -t nat -L -n -v</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 367 packets, 61770 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 366 packets, 61686 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 78 packets, 5838 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 78 packets, 5838 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    1    84 MASQUERADE  all  --  *      ens3    172.18.0.0/16        0.0.0.0/0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip netns exec netns_A ping -c 2 220.181.38.251</span></span><br><span class="line">PING 220.181.38.251 (220.181.38.251) 56(84) bytes of data.</span><br><span class="line">64 bytes from 220.181.38.251: icmp_seq=1 ttl=50 time=37.9 ms</span><br><span class="line">64 bytes from 220.181.38.251: icmp_seq=2 ttl=50 time=37.7 ms</span><br><span class="line"></span><br><span class="line">--- 220.181.38.251 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1001ms</span><br><span class="line">rtt min/avg/max/mdev = 37.668/37.785/37.902/0.117 ms</span><br></pre></td></tr></table></figure>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/network/">network</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2022/01/17/k8s-device-plugin/">
        <span class="next-text nav-default">Kubernetes Device Plugin</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
      <div class="comments" id="comments">
        <div id="gitalk-container"></div>
      </div>
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2022
    <span class="footer-author">WLBF.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    




  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'f891009fcd2431859813',
          clientSecret: '45a46aabb25c0175e2cb4fd784858a8420208623',
          repo: 'blogtalk',
          owner: 'WLBF',
          admin: ['WLBF'],
          id: md5(location.pathname),
          distractionFreeMode: false
        })
        gitalk.render('gitalk-container')
       </script>




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
